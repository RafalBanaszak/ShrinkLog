// MIT License
//
// Copyright (c) 2024 ShrinkLog Contributors
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#ifndef SHRINKLOG_SHRINGLOG_H
#define SHRINKLOG_SHRINGLOG_H

#include "Tags.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdint.h>
#include <stddef.h>

/*
 * The library requires to implement in the project a function SlogPutchar with following signature:
 * void SlogPutchar(char byte)
 */
void SlogPutchar(char byte);

#if !(SLOG_ID_BYTE_CNT >= 1 && SLOG_ID_BYTE_CNT <=4)
#error "Unsupported SLOG_ID_BYTE_CNT value. Proper value is in range [1, 4]\
and should be automatically generated by the ProjectProcessor"
#endif

#if SLOG_INT_PLAIN_B_SIZE != 1 && SLOG_INT_PLAIN_B_SIZE != 2 && SLOG_INT_PLAIN_B_SIZE != 4 && SLOG_INT_PLAIN_B_SIZE != 8
#error "Unsupported int size. Check SLOG_INT_PLAIN_B_SIZE definition. It should be 1, 2, 4 or 8."
#endif

#if SLOG_INT_MAX_B_SIZE != 1 && SLOG_INT_MAX_B_SIZE != 2 && SLOG_INT_MAX_B_SIZE != 4 && SLOG_INT_MAX_B_SIZE != 8
#error "Unsupported max int size. Check SLOG_INT_MAX_B_SIZE definition. It should be 1, 2, 4 or 8."
#endif

#if SLOG_INT_MAX_B_SIZE < SLOG_INT_PLAIN_B_SIZE
#error "Max int size is smaller than int size. Check SLOG_INT_MAX_B_SIZE definition"
#endif

static inline void SlogPutHexText(unsigned char symbol)
{
#ifdef SLOG_BINARY_MODE
    putchar(symbol);
#else /* Text mode */
    /* Convert byte to hex representation */
    static char halfByteToHex[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    SlogPutchar(halfByteToHex[(symbol >> 4) & 0x0F]);
    SlogPutchar(halfByteToHex[symbol & 0x0F]);
#endif
}

static inline void PrintStaticArgument(va_list* args, const uint_fast8_t size)
{
    int_fast8_t argIt;
#if SLOG_INT_MAX_B_SIZE == 8
    union
    {
        uint64_t var64;
        uint32_t var32;
        uint16_t var16;
        uint8_t  var8;
    } var;
#elif SLOG_INT_MAX_B_SIZE == 4
    union
    {
        uint32_t var32;
        uint16_t var16;
        uint8_t  var8;
    } var;
#endif

#if SLOG_INT_MAX_B_SIZE == 8
    #if SLOG_INT_PLAIN_B_SIZE == 8
        var.var64 = va_arg(*args, uint64_t);
    #elif SLOG_INT_PLAIN_B_SIZE == 4
        if (size == 8)  { var.var64 = va_arg(*args, uint64_t); }
        else            { var.var32 = va_arg(*args, uint32_t); }
    #elif SLOG_INT_PLAIN_B_SIZE == 2
        if      (size == 8) { var.var64 = va_arg(*args, uint64_t); }
        else if (size == 4) { var.var32 = va_arg(*args, uint32_t); }
        else                { var.var16 = va_arg(*args, uint16_t); }
    #elif SLOG_INT_PLAIN_B_SIZE == 1
        if      (size == 8) { var.var64 = va_arg(*args, uint64_t); }
        else if (size == 4) { var.var32 = va_arg(*args, uint32_t); }
        else if (size == 2) { var.var16 = va_arg(*args, uint16_t); }
        else                { var.var8  = va_arg(*args, uint8_t ); }
    #endif
    for (argIt = 0; argIt < size; ++argIt)
    {
        SlogPutHexText(var.var64 >> (8 * argIt));
    }
#elif SLOG_INT_MAX_B_SIZE == 4
    #if SLOG_INT_PLAIN_B_SIZE == 4
        var.var32 = va_arg(*args, uint32_t);
    #elif SLOG_INT_PLAIN_B_SIZE == 2
        if (size == 4)  { var.var32 = va_arg(*args, uint32_t); }
        else            { var.var16 = va_arg(*args, uint16_t); }
    #elif SLOG_INT_PLAIN_B_SIZE == 1
        if      (size == 4) { var.var32 = va_arg(*args, uint32_t); }
        else if (size == 2) { var.var16 = va_arg(*args, uint16_t); }
        else                { var.var8  = va_arg(*args, uint8_t);  }
    #endif
        for (argIt = 0; argIt < size; ++argIt)
        {
            SlogPutHexText(var.var32 >> (8 * argIt));
        }
#endif
}

#ifdef SLOG_LONG_DOUBLE_ENABLE
static inline void PrintLongDouble(va_list* args)
{
    int_fast8_t argIt;
    long double d = va_arg(*args, long double);
    const char* const buf = (char*)(&d);

    for (argIt = 0; argIt < 16; ++argIt)
    {
        SlogPutHexText(buf[argIt]);
    }
}
#endif

static inline void PrintDouble(va_list* args)
{
    int_fast8_t argIt;
    double d = va_arg(*args, double);
    const char* const buf = (char*)(&d);

    for (argIt = 0; argIt < 8; ++argIt)
    {
        SlogPutHexText(buf[argIt]);
    }
}

static inline void PrintStringArgument(va_list* args)
{
    int_fast16_t stringIt = 0;
    char* str = (char*)va_arg(*args, char*);
    while(str[stringIt] != '\0'){
        SlogPutchar(str[stringIt++]);
    }
    SlogPutchar('\0');
}

void LOG(char* tag, char* message, ...){
    uint_fast8_t tagIt = 0;
    va_list args;
    va_start(args, message);

    for (; tagIt < SLOG_ID_BYTE_CNT; ++tagIt){
        SlogPutHexText(tag[tagIt]);
    }

    while(tag[tagIt] != '\0'){
        /* Get integer arguments which byte size is known */
        if(tag[tagIt] <= 0x08){
            PrintStaticArgument(&args, tag[tagIt]);
        }
        /* Get doubles */
        else if(tag[tagIt] == 0x18){
            PrintDouble(&args);
        }
#ifdef SLOG_LONG_DOUBLE_ENABLE
        else if(tag[tagIt] == 0x20){
            PrintLongDouble(&args);
        }
#endif
        /* Get dynamic arguments which byte size is NOT known */
        else if (tag[tagIt] == 0x7F) {
            PrintStringArgument(&args);
        }
        ++tagIt;
    }
#ifndef SLOG_BINARY_MODE
    putchar('\n');
#endif
    va_end(args);
}

#endif //SHRINKLOG_SHRINGLOG_H
